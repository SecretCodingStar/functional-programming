{"version":3,"sources":["either-compiled.js"],"names":[],"mappings":"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","file":"either-compiled-compiled.js","sourcesContent":["'use strict';\n\nvar clone = Object.create;\nvar unimplemented = function unimplemented() {\n    throw new Error('Not implemented.');\n};\nvar noop = function noop() {\n    return this;\n};\n\n// -- Implementation ---------------------------------------------------\n\n/**\n * The `Either(a, b)` structure represents the logical disjunction between `a`\n * and `b`. In other words, `Either` may contain either a value of type `a` or\n * a value of type `b`, at any given time. This particular implementation is\n * biased on the right value (`b`), thus projections will take the right value\n * over the left one.\n *\n * This class models two different cases: `Left a` and `Right b`, and can hold\n * one of the cases at any given time. The projections are, none the less,\n * biased for the `Right` case, thus a common use case for this structure is to\n * hold the results of computations that may fail, when you want to store\n * additional information on the failure (instead of throwing an exception).\n *\n * Furthermore, the values of `Either(a, b)` can be combined and manipulated by\n * using the expressive monadic operations. This allows safely sequencing\n * operations that may fail, and safely composing values that you don't know\n * whether they're present or not, failing early (returning a `Left a`) if any\n * of the operations fail.\n *\n * While this class can certainly model input validations, the [Validation][]\n * structure lends itself better to that use case, since it can naturally\n * aggregate failures — monads shortcut on the first failure.\n *\n * [Validation]: https://github.com/folktale/data.validation\n *\n *\n * @class\n * @summary\n * Either[α, β] <: Applicative[β]\n *               , Functor[β]\n *               , Chain[β]\n *               , Show\n *               , Eq\n */\nfunction Either() {}\n\nLeft.prototype = clone(Either.prototype);\nfunction Left(a) {\n    this.value = a;\n}\n\nRight.prototype = clone(Either.prototype);\nfunction Right(a) {\n    this.value = a;\n}\n\n// -- Constructors -----------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure holding a `Left` value. This\n * usually represents a failure due to the right-bias of this structure.\n *\n * @summary a → Either[α, β]\n */\nEither.Left = function (a) {\n    return new Left(a);\n};\nEither.prototype.Left = Either.Left;\n\n/**\n * Constructs a new `Etiher[α, β]` structure holding a `Right` value. This\n * usually represents a successful value due to the right bias of this\n * structure.\n *\n * @summary β → Either[α, β]\n */\nEither.Right = function (a) {\n    return new Right(a);\n};\nEither.prototype.Right = Either.Right;\n\n// -- Conversions ------------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure from a nullable type.\n *\n * Takes the `Left` case if the value is `null` or `undefined`. Takes the\n * `Right` case otherwise.\n *\n * @summary α → Either[α, α]\n */\nEither.fromNullable = function (a) {\n    return a != null ? this.Right(a) : /* otherwise */this.Left(a);\n};\nEither.prototype.fromNullable = Either.fromNullable;\n\n/**\n * Constructs a new `Either[α, β]` structure from a `Validation[α, β]` type.\n *\n * @summary Validation[α, β] → Either[α, β]\n */\nEither.fromValidation = function (a) {\n    return a.fold(this.Left.bind(this), this.Right.bind(this));\n};\n\n// -- Predicates -------------------------------------------------------\n\n/**\n * True if the `Either[α, β]` contains a `Left` value.\n *\n * @summary Boolean\n */\nEither.prototype.isLeft = false;\nLeft.prototype.isLeft = true;\n\n/**\n * True if the `Either[α, β]` contains a `Right` value.\n *\n * @summary Boolean\n */\nEither.prototype.isRight = false;\nRight.prototype.isRight = true;\n\n// -- Applicative ------------------------------------------------------\n\n/**\n * Creates a new `Either[α, β]` instance holding the `Right` value `b`.\n *\n * `b` can be any value, including `null`, `undefined` or another\n * `Either[α, β]` structure.\n *\n * @summary β → Either[α, β]\n */\nEither.of = function (a) {\n    return this.Right(a);\n};\nEither.prototype.of = Either.of;\n\n// -- Functor ----------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using a regular\n * unary function.\n *\n * @method\n * @summary (@Either[α, β]) => (β → γ) → Either[α, γ]\n */\nEither.prototype.map = unimplemented;\nLeft.prototype.map = noop;\n\nRight.prototype.map = function (f) {\n    return this.of(f(this.value));\n};\n\n// -- Chain ------------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using an unary\n * function to monads.\n *\n * @method\n * @summary (@Either[α, β], m:Monad[_]) => (β → m[γ]) → m[γ]\n */\nEither.prototype.chain = unimplemented;\nLeft.prototype.chain = noop;\n\nRight.prototype.chain = function (f) {\n    return f(this.value);\n};\n\n// -- Show -------------------------------------------------------------\n\n/**\n * Returns a textual representation of the `Either[α, β]` structure.\n *\n * @method\n * @summary (@Either[α, β]) => Void → String\n */\nEither.prototype.toString = unimplemented;\n\nLeft.prototype.toString = function () {\n    return 'Either.Left(' + this.value + ')';\n};\n\nRight.prototype.toString = function () {\n    return 'Either.Right(' + this.value + ')';\n};\n\n// -- Eq ---------------------------------------------------------------\n\n/**\n * Tests if an `Either[α, β]` structure is equal to another `Either[α, β]`\n * structure.\n *\n * @method\n * @summary (@Either[α, β]) => Either[α, β] → Boolean\n */\nEither.prototype.isEqual = unimplemented;\n\nLeft.prototype.isEqual = function (a) {\n    return a.isLeft && a.value === this.value;\n};\n\nRight.prototype.isEqual = function (a) {\n    return a.isRight && a.value === this.value;\n};\n\n// -- Extracting and recovering ----------------------------------------\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure, if it\n * exists. Otherwise throws a `TypeError`.\n *\n * @method\n * @summary (@Either[α, β]) => Void → β         :: partial, throws\n * @see {@link module:lib/either~Either#getOrElse} — A getter that can handle failures.\n * @see {@link module:lib/either~Either#merge} — The convergence of both values.\n * @throws {TypeError} if the structure has no `Right` value.\n */\nEither.prototype.get = unimplemented;\n\nLeft.prototype.get = function () {\n    throw new TypeError('Can\\'t extract the value of a Left(a).');\n};\n\nRight.prototype.get = function () {\n    return this.value;\n};\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure. If the\n * structure doesn't have a `Right` value, returns the given default.\n *\n * @method\n * @summary (@Either[α, β]) => β → β\n */\nEither.prototype.getOrElse = unimplemented;\n\nLeft.prototype.getOrElse = function (a) {\n    return a;\n};\n\nRight.prototype.getOrElse = function (_) {\n    return this.value;\n};\n\n/**\n * Transforms a `Left` value into a new `Either[α, β]` structure. Does nothing\n * if the structure contain a `Right` value.\n *\n * @method\n * @summary (@Either[α, β]) => (α → Either[γ, β]) → Either[γ, β]\n */\nEither.prototype.orElse = unimplemented;\nRight.prototype.orElse = noop;\n\nLeft.prototype.orElse = function (f) {\n    return f(this.value);\n};\n\n/**\n * Returns the value of whichever side of the disjunction that is present.\n *\n * @summary (@Either[α, α]) => Void → α\n */\nEither.prototype.merge = function () {\n    return this.value;\n};\n\n// -- Folds and Extended Transformations -------------------------------\n\n/**\n * Applies a function to each case in this data structure.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ), (β → γ) → γ\n */\nEither.prototype.fold = unimplemented;\n\nLeft.prototype.fold = function (f, _) {\n    return f(this.value);\n};\n\nRight.prototype.fold = function (_, g) {\n    return g(this.value);\n};\n\n/**\n * Catamorphism.\n *\n * @method\n * @summary (@Either[α, β]) => { Left: α → γ, Right: β → γ } → γ\n */\nEither.prototype.cata = unimplemented;\n\nLeft.prototype.cata = function (pattern) {\n    return pattern.Left(this.value);\n};\n\nRight.prototype.cata = function (pattern) {\n    return pattern.Right(this.value);\n};\n\n/**\n * Swaps the disjunction values.\n *\n * @method\n * @summary (@Either[α, β]) => Void → Either[β, α]\n */\nEither.prototype.swap = unimplemented;\n\nLeft.prototype.swap = function () {\n    return this.Right(this.value);\n};\n\nRight.prototype.swap = function () {\n    return this.Left(this.value);\n};\n\n/**\n * Maps the left side of the disjunction.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ) → Either[γ, β]\n */\nEither.prototype.leftMap = unimplemented;\nRight.prototype.leftMap = noop;\n\nLeft.prototype.leftMap = function (f) {\n    return this.Left(f(this.value));\n};\n\nEither.prototype.getOrElseThrow = unimplemented;\n\nLeft.prototype.getOrElseThrow = function (a) {\n    throw new Error(a);\n};\n\nRight.prototype.getOrElseThrow = function (_) {\n    return this.value;\n};\n\nEither.prototype.filter = unimplemented;\nLeft.prototype.filter = noop;\n\nRight.prototype.filter = function (f) {\n    return this.fromNullable(f(this.value) ? this.value : null);\n};\n\n//# sourceMappingURL=either-compiled.js.map"]}