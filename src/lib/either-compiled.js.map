{"version":3,"sources":["either.js"],"names":[],"mappings":"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","file":"either-compiled.js","sourcesContent":["var clone         = Object.create\nvar unimplemented = function(){ throw new Error('Not implemented.') }\nvar noop          = function(){ return this                         }\n\n\n// -- Implementation ---------------------------------------------------\n\n/**\n * The `Either(a, b)` structure represents the logical disjunction between `a`\n * and `b`. In other words, `Either` may contain either a value of type `a` or\n * a value of type `b`, at any given time. This particular implementation is\n * biased on the right value (`b`), thus projections will take the right value\n * over the left one.\n *\n * This class models two different cases: `Left a` and `Right b`, and can hold\n * one of the cases at any given time. The projections are, none the less,\n * biased for the `Right` case, thus a common use case for this structure is to\n * hold the results of computations that may fail, when you want to store\n * additional information on the failure (instead of throwing an exception).\n *\n * Furthermore, the values of `Either(a, b)` can be combined and manipulated by\n * using the expressive monadic operations. This allows safely sequencing\n * operations that may fail, and safely composing values that you don't know\n * whether they're present or not, failing early (returning a `Left a`) if any\n * of the operations fail.\n *\n * While this class can certainly model input validations, the [Validation][]\n * structure lends itself better to that use case, since it can naturally\n * aggregate failures — monads shortcut on the first failure.\n *\n * [Validation]: https://github.com/folktale/data.validation\n *\n *\n * @class\n * @summary\n * Either[α, β] <: Applicative[β]\n *               , Functor[β]\n *               , Chain[β]\n *               , Show\n *               , Eq\n */\nfunction Either() { }\n\nLeft.prototype = clone(Either.prototype)\nfunction Left(a) {\n    this.value = a\n}\n\nRight.prototype = clone(Either.prototype)\nfunction Right(a) {\n    this.value = a\n}\n\n// -- Constructors -----------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure holding a `Left` value. This\n * usually represents a failure due to the right-bias of this structure.\n *\n * @summary a → Either[α, β]\n */\nEither.Left = function(a) {\n    return new Left(a)\n}\nEither.prototype.Left = Either.Left\n\n/**\n * Constructs a new `Etiher[α, β]` structure holding a `Right` value. This\n * usually represents a successful value due to the right bias of this\n * structure.\n *\n * @summary β → Either[α, β]\n */\nEither.Right = function(a) {\n    return new Right(a)\n}\nEither.prototype.Right = Either.Right\n\n\n// -- Conversions ------------------------------------------------------\n\n/**\n * Constructs a new `Either[α, β]` structure from a nullable type.\n *\n * Takes the `Left` case if the value is `null` or `undefined`. Takes the\n * `Right` case otherwise.\n *\n * @summary α → Either[α, α]\n */\nEither.fromNullable = function(a) {\n    return a != null?       this.Right(a)\n        :      /* otherwise */  this.Left(a)\n}\nEither.prototype.fromNullable = Either.fromNullable\n\n/**\n * Constructs a new `Either[α, β]` structure from a `Validation[α, β]` type.\n *\n * @summary Validation[α, β] → Either[α, β]\n */\nEither.fromValidation = function(a) {\n    return a.fold(this.Left.bind(this), this.Right.bind(this))\n}\n\n\n// -- Predicates -------------------------------------------------------\n\n/**\n * True if the `Either[α, β]` contains a `Left` value.\n *\n * @summary Boolean\n */\nEither.prototype.isLeft = false\nLeft.prototype.isLeft   = true\n\n/**\n * True if the `Either[α, β]` contains a `Right` value.\n *\n * @summary Boolean\n */\nEither.prototype.isRight = false\nRight.prototype.isRight  = true\n\n\n// -- Applicative ------------------------------------------------------\n\n/**\n * Creates a new `Either[α, β]` instance holding the `Right` value `b`.\n *\n * `b` can be any value, including `null`, `undefined` or another\n * `Either[α, β]` structure.\n *\n * @summary β → Either[α, β]\n */\nEither.of = function(a) {\n    return this.Right(a)\n}\nEither.prototype.of = Either.of\n\n\n\n\n// -- Functor ----------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using a regular\n * unary function.\n *\n * @method\n * @summary (@Either[α, β]) => (β → γ) → Either[α, γ]\n */\nEither.prototype.map = unimplemented\nLeft.prototype.map   = noop\n\nRight.prototype.map = function(f) {\n    return this.of(f(this.value))\n}\n\n\n// -- Chain ------------------------------------------------------------\n\n/**\n * Transforms the `Right` value of the `Either[α, β]` structure using an unary\n * function to monads.\n *\n * @method\n * @summary (@Either[α, β], m:Monad[_]) => (β → m[γ]) → m[γ]\n */\nEither.prototype.chain = unimplemented\nLeft.prototype.chain   = noop\n\nRight.prototype.chain = function(f) {\n    return f(this.value)\n};\n\n\n// -- Show -------------------------------------------------------------\n\n/**\n * Returns a textual representation of the `Either[α, β]` structure.\n *\n * @method\n * @summary (@Either[α, β]) => Void → String\n */\nEither.prototype.toString = unimplemented\n\nLeft.prototype.toString = function() {\n    return 'Either.Left(' + this.value + ')'\n}\n\nRight.prototype.toString = function() {\n    return 'Either.Right(' + this.value + ')'\n}\n\n\n// -- Eq ---------------------------------------------------------------\n\n/**\n * Tests if an `Either[α, β]` structure is equal to another `Either[α, β]`\n * structure.\n *\n * @method\n * @summary (@Either[α, β]) => Either[α, β] → Boolean\n */\nEither.prototype.isEqual = unimplemented\n\nLeft.prototype.isEqual = function(a) {\n    return a.isLeft && (a.value === this.value)\n}\n\nRight.prototype.isEqual = function(a) {\n    return a.isRight && (a.value === this.value)\n}\n\n\n// -- Extracting and recovering ----------------------------------------\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure, if it\n * exists. Otherwise throws a `TypeError`.\n *\n * @method\n * @summary (@Either[α, β]) => Void → β         :: partial, throws\n * @see {@link module:lib/either~Either#getOrElse} — A getter that can handle failures.\n * @see {@link module:lib/either~Either#merge} — The convergence of both values.\n * @throws {TypeError} if the structure has no `Right` value.\n */\nEither.prototype.get = unimplemented\n\nLeft.prototype.get = function() {\n    throw new TypeError(\"Can't extract the value of a Left(a).\")\n}\n\nRight.prototype.get = function() {\n    return this.value\n}\n\n\n/**\n * Extracts the `Right` value out of the `Either[α, β]` structure. If the\n * structure doesn't have a `Right` value, returns the given default.\n *\n * @method\n * @summary (@Either[α, β]) => β → β\n */\nEither.prototype.getOrElse = unimplemented\n\nLeft.prototype.getOrElse = function(a) {\n    return a\n}\n\nRight.prototype.getOrElse = function(_) {\n    return this.value\n}\n\n\n/**\n * Transforms a `Left` value into a new `Either[α, β]` structure. Does nothing\n * if the structure contain a `Right` value.\n *\n * @method\n * @summary (@Either[α, β]) => (α → Either[γ, β]) → Either[γ, β]\n */\nEither.prototype.orElse = unimplemented\nRight.prototype.orElse  = noop\n\nLeft.prototype.orElse = function(f) {\n    return f(this.value)\n};\n\n\n/**\n * Returns the value of whichever side of the disjunction that is present.\n *\n * @summary (@Either[α, α]) => Void → α\n */\nEither.prototype.merge = function() {\n    return this.value\n}\n\n\n// -- Folds and Extended Transformations -------------------------------\n\n/**\n * Applies a function to each case in this data structure.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ), (β → γ) → γ\n */\nEither.prototype.fold = unimplemented\n\nLeft.prototype.fold = function(f, _) {\n    return f(this.value)\n}\n\nRight.prototype.fold = function(_, g) {\n    return g(this.value)\n}\n\n/**\n * Catamorphism.\n *\n * @method\n * @summary (@Either[α, β]) => { Left: α → γ, Right: β → γ } → γ\n */\nEither.prototype.cata = unimplemented\n\nLeft.prototype.cata = function(pattern) {\n    return pattern.Left(this.value)\n}\n\nRight.prototype.cata = function(pattern) {\n    return pattern.Right(this.value)\n}\n\n\n/**\n * Swaps the disjunction values.\n *\n * @method\n * @summary (@Either[α, β]) => Void → Either[β, α]\n */\nEither.prototype.swap = unimplemented\n\nLeft.prototype.swap = function() {\n    return this.Right(this.value)\n};\n\nRight.prototype.swap = function() {\n    return this.Left(this.value)\n};\n\n\n/**\n * Maps the left side of the disjunction.\n *\n * @method\n * @summary (@Either[α, β]) => (α → γ) → Either[γ, β]\n */\nEither.prototype.leftMap = unimplemented\nRight.prototype.leftMap  = noop\n\nLeft.prototype.leftMap = function(f) {\n    return this.Left(f(this.value))\n}\n\nEither.prototype.getOrElseThrow = unimplemented\n\nLeft.prototype.getOrElseThrow = function(a) {\n    throw new Error(a);\n};\n\nRight.prototype.getOrElseThrow = function(_) {\n    return this.value;\n}\n\nEither.prototype.filter = unimplemented;\nLeft.prototype.filter   = noop;\n\nRight.prototype.filter = function(f) {\n    return this.fromNullable(f(this.value) ? this.value : null);\n};"]}